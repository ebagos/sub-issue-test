package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/joho/godotenv"
)

const (
	estimatedLabel  = "è¦‹ç©æ™‚é–“"
	actualLabel     = "å®Ÿç¸¾æ™‚é–“"
	sbiLabel        = "sbi"
	devSbiLabel     = "dev-sbi"
	pbiLabel        = "pbi"
	devPbiLabel     = "dev-pbi"
	diffLowLabel    = "Difficulty:Low"
	diffMiddleLabel = "Difficulty:Middle"
	diffHighLabel   = "Difficulty:High"
	jstOffset       = 9 * 60 * 60 // JSTã¯ UTC+9æ™‚é–“
)

// JSTã®å®šç¾©ï¼ˆãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãƒ¬ãƒ™ãƒ«ã§å®šç¾©ï¼‰
var jst = time.FixedZone("JST", jstOffset)

// IssueTimeInfo ã¯Issueã®æ™‚é–“æƒ…å ±ã‚’æ ¼ç´ã™ã‚‹æ§‹é€ ä½“
type IssueTimeInfo struct {
	IssueURL      string     `json:"issue_url"`
	Title         string     `json:"title"`
	Author        string     `json:"author"`
	Assignees     []string   `json:"assignees"`
	CreatedAt     time.Time  `json:"created_at"` // nilã«ãªã‚‰ãªã„ã‚ˆã†ã«å€¤å‹ã«ã™ã‚‹
	ClosedAt      *time.Time `json:"closed_at"`  // é–‰ã˜ã¦ã„ãªã„å ´åˆã¯nilã«ãªã‚‹ãŸã‚ãƒã‚¤ãƒ³ã‚¿
	State         string     `json:"state"`
	StateReason   string     `json:"state_reason"`
	EstimatedTime float64    `json:"estimated_time"`
	ActualTime    float64    `json:"actual_time"`
	Size          float64    `json:"size"` // è¿½åŠ : ã‚µã‚¤ã‚º
	Labels        []string   `json:"labels"`
}

// GraphQLClient ã¯GraphQL APIã¸ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å‡¦ç†ã™ã‚‹ç°¡æ˜“ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
type GraphQLClient struct {
	httpClient *http.Client
	endpoint   string
	token      string
}

// GraphQLRequest ã¯GraphQLãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’è¡¨ã™æ§‹é€ ä½“
type GraphQLRequest struct {
	Query     string                 `json:"query"`
	Variables map[string]interface{} `json:"variables"`
}

// GraphQLResponse ã¯GraphQLãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’è¡¨ã™æ§‹é€ ä½“
type GraphQLResponse struct {
	Data   json.RawMessage `json:"data"`
	Errors []struct {
		Message string `json:"message"`
	} `json:"errors"`
}

// ProjectQueryResponse ã¯ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚¯ã‚¨ãƒªã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ§‹é€ 
type ProjectQueryResponse struct {
	Organization struct {
		ProjectV2 struct {
			Title string
			Items struct {
				PageInfo struct {
					HasNextPage bool
					EndCursor   *string
				}
				Nodes []struct {
					Content struct {
						TypeName    string `json:"__typename"`
						Number      int
						Title       string
						State       string
						StateReason *string
						Author      struct {
							Login string
						}
						Labels struct {
							Nodes []struct {
								Name string
							}
						}
						Assignees struct {
							Nodes []struct {
								Login string
							}
						}
						URL        string
						Repository struct {
							Name string
						}
						CreatedAt string // Issueã®ä½œæˆæ—¥æ™‚
						ClosedAt  *string
					} `json:"content"`
					FieldValues struct {
						Nodes []struct {
							TypeName string `json:"__typename"`
							// æ•°å€¤ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ç”¨ï¼ˆè¦‹ç©æ™‚é–“ã€å®Ÿç¸¾æ™‚é–“ãªã©ï¼‰
							Field struct {
								Name string
							} `json:"field,omitempty"`
							Number *float64 `json:"number,omitempty"`
							// ä»¥ä¸‹ã¯ä»–ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚¿ã‚¤ãƒ—ç”¨ã ãŒã€ä»Šå›ã¯ä½¿ç”¨ã—ãªã„
							Name  *string `json:"name,omitempty"`
							Title string  `json:"title,omitempty"`
							Text  string  `json:"text,omitempty"`
							Date  string  `json:"date,omitempty"`
						}
					}
				}
			}
		}
	}
}

// FilterOptions ã¯è¤‡æ•°ã®ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’æ ¼ç´ã™ã‚‹æ§‹é€ ä½“
type FilterOptions struct {
	ClosedDateRange     *DateRange    // é–‰ã˜ã‚‰ã‚ŒãŸæ—¥ä»˜ã®ç¯„å›²
	CreatedAfterDate    *time.Time    // æŒ‡å®šæ—¥ä»¥é™ã«ä½œæˆã•ã‚ŒãŸ
	IncludeOpenIssues   bool          // æœªé–‰ã˜Issueã‚’å«ã‚€ã‹
	WeeklyPeriod        *WeeklyPeriod // é€±æ¬¡æœŸé–“
	RequireSbiLabel     bool          // "sbi"ãƒ©ãƒ™ãƒ«ãŒå¿…è¦ã‹
	ExcludeNotPlanned   bool          // "NOT_PLANNED"ã§é–‰ã˜ã‚‰ã‚ŒãŸIssueã‚’é™¤å¤–ã™ã‚‹ã‹
	AllowedRepositories []string      // å¯¾è±¡ãƒªãƒã‚¸ãƒˆãƒªã®ãƒªã‚¹ãƒˆ
}

// DateRange ã¯æ—¥ä»˜ç¯„å›²ã‚’è¡¨ã™æ§‹é€ ä½“
type DateRange struct {
	StartDate time.Time
	EndDate   time.Time
}

// WeeklyPeriod ã¯é€±é–“æœŸé–“ã‚’è¡¨ã™æ§‹é€ ä½“
type WeeklyPeriod struct {
	StartDate time.Time
	EndDate   time.Time
	Weekday   int
}

// NewGraphQLClient ã¯æ–°ã—ã„GraphQLã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’ä½œæˆã™ã‚‹
func NewGraphQLClient(token string) *GraphQLClient {
	return &GraphQLClient{
		httpClient: &http.Client{},
		endpoint:   "https://api.github.com/graphql",
		token:      token,
	}
}

// Execute ã¯GraphQLã‚¯ã‚¨ãƒªã‚’å®Ÿè¡Œã™ã‚‹
func (c *GraphQLClient) Execute(ctx context.Context, query string, variables map[string]interface{}, responseData interface{}) error {
	// ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®æº–å‚™
	req := GraphQLRequest{
		Query:     query,
		Variables: variables,
	}
	reqBody, err := json.Marshal(req)
	if err != nil {
		return fmt.Errorf("marshaling request: %w", err)
	}

	// HTTPãƒªã‚¯ã‚¨ã‚¹ãƒˆã®ä½œæˆ
	httpReq, err := http.NewRequest("POST", c.endpoint, strings.NewReader(string(reqBody)))
	if err != nil {
		return fmt.Errorf("creating request: %w", err)
	}
	httpReq.Header.Set("Authorization", "bearer "+c.token)
	httpReq.Header.Set("Content-Type", "application/json")

	// ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®å®Ÿè¡Œ
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return fmt.Errorf("executing request: %w", err)
	}
	defer resp.Body.Close()

	// ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®è§£æ
	var graphqlResp GraphQLResponse
	if err := json.NewDecoder(resp.Body).Decode(&graphqlResp); err != nil {
		return fmt.Errorf("decoding response: %w", err)
	}

	// ã‚¨ãƒ©ãƒ¼ãƒã‚§ãƒƒã‚¯
	if len(graphqlResp.Errors) > 0 {
		return fmt.Errorf("graphql errors: %s", graphqlResp.Errors[0].Message)
	}

	// ãƒ‡ãƒ¼ã‚¿ã®è§£æ
	if err := json.Unmarshal(graphqlResp.Data, responseData); err != nil {
		return fmt.Errorf("unmarshaling data: %w", err)
	}

	return nil
}

// parseJSTDate ã¯JSTã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³ã§æ—¥ä»˜ã‚’è§£æã™ã‚‹
func parseJSTDate(dateStr string) (time.Time, error) {
	return time.ParseInLocation("2006-01-02", dateStr, jst)
}

// calculateWeeklyPeriod ã¯æ˜¨æ—¥ã‚’å«ã‚€é€±ã®ç‰¹å®šæ›œæ—¥ã‹ã‚‰ã®1é€±é–“ã®æœŸé–“ã‚’è¨ˆç®—ã™ã‚‹
func calculateWeeklyPeriod(weekday int) WeeklyPeriod {
	// æ˜¨æ—¥ã®æ—¥æ™‚ï¼ˆJSTï¼‰
	yesterday := time.Now().In(jst).AddDate(0, 0, -1)

	// æ˜¨æ—¥ãŒå«ã¾ã‚Œã‚‹é€±ã®é–‹å§‹æ›œæ—¥ã‚’è¨ˆç®—
	daysSinceTargetWeekday := (int(yesterday.Weekday()) - weekday + 7) % 7
	lastTargetWeekday := yesterday.AddDate(0, 0, -daysSinceTargetWeekday)

	// æ™‚åˆ»éƒ¨åˆ†ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¦ã€ãã®æ—¥ã®00:00:00ã«è¨­å®š
	lastTargetWeekday = time.Date(
		lastTargetWeekday.Year(), lastTargetWeekday.Month(), lastTargetWeekday.Day(),
		0, 0, 0, 0, jst)

	// æ¬¡ã®é€±ã®åŒã˜æ›œæ—¥(æœŸé–“ã®çµ‚äº†æ—¥ã¯å«ã¾ãªã„)
	// 7æ—¥å¾Œã®00:00:00ãŒçµ‚äº†æ™‚åˆ»ã€ã¤ã¾ã‚Šå‰æ—¥ã®23:59:59ã¾ã§ãŒå¯¾è±¡
	nextWeekSameDay := lastTargetWeekday.AddDate(0, 0, 7)

	return WeeklyPeriod{
		StartDate: lastTargetWeekday,
		EndDate:   nextWeekSameDay,
		Weekday:   weekday,
	}
}

func main() {
	// ç’°å¢ƒå¤‰æ•°ã®ãƒ­ãƒ¼ãƒ‰
	if err := godotenv.Load(); err != nil {
		log.Println("No .env file found, using existing environment variables")
	}

	// å¿…è¦ãªç’°å¢ƒå¤‰æ•°ã®å–å¾—
	org := os.Getenv("ORG")
	if org == "" {
		log.Fatal("ORG environment variable must be set")
	}

	projectStr := os.Getenv("PROJECT")
	if projectStr == "" {
		log.Fatal("PROJECT environment variable must be set")
	}
	projectNum, err := strconv.Atoi(projectStr)
	if err != nil {
		log.Fatalf("Invalid PROJECT number: %v", err)
	}

	reposStr := os.Getenv("REPOS")
	if reposStr == "" {
		log.Fatal("REPOS environment variable must be set")
	}
	repos := strings.Split(reposStr, ",")
	// ãƒªãƒã‚¸ãƒˆãƒªåã‚’ãƒˆãƒªãƒ 
	for i := range repos {
		repos[i] = strings.TrimSpace(repos[i])
	}

	// ã‚µã‚¤ã‚ºã®ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åã‚’ç’°å¢ƒå¤‰æ•°ã‹ã‚‰å–å¾—
	sizeLabel := os.Getenv("SIZE_LABEL")
	if sizeLabel == "" {
		log.Fatal("SIZE_LABEL environment variable must be set")
	}

	// ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ä½œæˆ
	filterOptions := FilterOptions{
		IncludeOpenIssues:   false, // é–‰ã˜ã‚‰ã‚ŒãŸIssueã®ã¿ã‚’å¯¾è±¡ã¨ã™ã‚‹
		RequireSbiLabel:     false, // ã™ã¹ã¦ã®Issueã‚’å¯¾è±¡ã¨ã™ã‚‹
		ExcludeNotPlanned:   true,  // "NOT_PLANNED"ã§é–‰ã˜ã‚‰ã‚ŒãŸIssueã‚’é™¤å¤–
		AllowedRepositories: repos, // å¯¾è±¡ãƒªãƒã‚¸ãƒˆãƒª
	}

	// æ—¥ä»˜ãƒ•ã‚£ãƒ«ã‚¿ã®å–å¾—ã¨è§£æ - å¿…é ˆé …ç›®ã¨ã—ã¦æ‰±ã†
	startDateStr := os.Getenv("START_DATE")
	if startDateStr == "" {
		log.Fatal("START_DATE environment variable must be set")
	}

	endDateStr := os.Getenv("END_DATE")
	if endDateStr == "" {
		log.Fatal("END_DATE environment variable must be set")
	}

	startDate, err := parseJSTDate(startDateStr)
	if err != nil {
		log.Fatalf("Invalid START_DATE format: %v", err)
	}

	endDate, err := parseJSTDate(endDateStr)
	if err != nil {
		log.Fatalf("Invalid END_DATE format: %v", err)
	}
	// çµ‚äº†æ—¥ã®çµ‚ã‚ã‚Šã¾ã§ã‚’å«ã‚ã‚‹ãŸã‚ã«23:59:59ã«è¨­å®š
	endDate = endDate.Add(24*time.Hour - time.Second)

	filterOptions.ClosedDateRange = &DateRange{
		StartDate: startDate,
		EndDate:   endDate,
	}

	// GitHubãƒˆãƒ¼ã‚¯ãƒ³ã®å–å¾—
	token := getGitHubToken()

	// GraphQLã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®åˆæœŸåŒ–
	client := NewGraphQLClient(token)
	ctx := context.Background()

	// ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰Issueã‚’å–å¾—
	allIssues, err := fetchAllProjectIssues(client, ctx, org, projectNum, sizeLabel)
	if err != nil {
		log.Fatalf("Error fetching issues from project: %v", err)
	}

	// ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã‚’é©ç”¨
	filteredIssues := filterIssues(allIssues, filterOptions)

	// çµæœã®å‡ºåŠ›
	if len(filteredIssues) == 0 {
		fmt.Printf("No issues found that were closed between %s and %s\n",
			startDateStr, endDateStr)
		return
	}

	fmt.Printf("Found %d issues closed between %s and %s in repositories: %s\n\n",
		len(filteredIssues), startDateStr, endDateStr, strings.Join(repos, ", "))

	// å…¥åŠ›ãƒã‚§ãƒƒã‚¯ã®å®Ÿè¡Œã¨çµæœè¡¨ç¤º
	validateAndDisplayIssuesWithIncorrectFields(filteredIssues)
}

// fetchAllProjectIssues ã¯ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ã™ã¹ã¦ã®Issueã‚’å–å¾—ã™ã‚‹ï¼ˆãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ãªã—ï¼‰
func fetchAllProjectIssues(client *GraphQLClient, ctx context.Context, org string, projectNum int, sizeLabel string) ([]IssueTimeInfo, error) {
	var allIssues []IssueTimeInfo
	cursor := ""

	// GraphQLã‚¯ã‚¨ãƒªã®æº–å‚™
	query := `
	query ProjectIssues($org: String!, $projectNum: Int!, $cursor: String) {
		organization(login: $org) {
			projectV2(number: $projectNum) {
				title
				items(first: 100, after: $cursor) {
					pageInfo {
						hasNextPage
						endCursor
					}
					nodes {
						content {
							__typename
							... on Issue {
								number
								title
								state
								stateReason
								author {
									login
								}
								labels(first: 100) {
									nodes {
										name
									}
								}
								assignees(first: 10) {
									nodes {
										login
									}
								}
								url
								repository {
									name
								}
								createdAt
								closedAt
							}
						}
						fieldValues(first: 100) {
							nodes {
								__typename
								... on ProjectV2ItemFieldNumberValue {
									field {
										... on ProjectV2FieldCommon {
											name
										}
									}
									number
								}
							}
						}
					}
				}
			}
		}
	}`

	// ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³å‡¦ç†
	for {
		variables := map[string]interface{}{
			"org":        org,
			"projectNum": projectNum,
		}

		if cursor != "" {
			variables["cursor"] = cursor
		}

		var response ProjectQueryResponse
		err := client.Execute(ctx, query, variables, &response)
		if err != nil {
			return nil, fmt.Errorf("executing GraphQL query: %w", err)
		}

		// å„Issueã‚’å‡¦ç†
		for _, node := range response.Organization.ProjectV2.Items.Nodes {
			// Issueã§ãªã„å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
			if node.Content.TypeName != "Issue" {
				continue
			}

			// ä½œæˆæ—¥æ™‚ã‚’ãƒ‘ãƒ¼ã‚¹
			createdAtUTC, err := time.Parse(time.RFC3339, node.Content.CreatedAt)
			if err != nil {
				log.Printf("Error parsing createdAt time for issue #%d: %v", node.Content.Number, err)
				continue
			}
			// UTCã‹ã‚‰JSTã¸å¤‰æ›
			createdAtJST := createdAtUTC.In(jst)

			// é–‰ã˜ã‚‰ã‚ŒãŸæ—¥æ™‚ã‚’ãƒ‘ãƒ¼ã‚¹
			var closedAt *time.Time
			if node.Content.ClosedAt != nil {
				// GitHubã‹ã‚‰è¿”ã•ã‚Œã‚‹æ™‚åˆ»ã¯UTCãªã®ã§ãƒ‘ãƒ¼ã‚¹å¾Œã«JSTã«å¤‰æ›
				parsedTimeUTC, err := time.Parse(time.RFC3339, *node.Content.ClosedAt)
				if err != nil {
					log.Printf("Error parsing closedAt time for issue #%d: %v", node.Content.Number, err)
					continue
				}

				// UTCã‹ã‚‰JSTã«å¤‰æ›
				parsedTimeJST := parsedTimeUTC.In(jst)
				closedAt = &parsedTimeJST
			}

			// ã‚¢ã‚µã‚¤ãƒ³ã•ã‚ŒãŸãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å–å¾—
			assignees := make([]string, 0, len(node.Content.Assignees.Nodes))
			for _, assignee := range node.Content.Assignees.Nodes {
				assignees = append(assignees, assignee.Login)
			}

			// ãƒ©ãƒ™ãƒ«ã®å–å¾—
			labels := make([]string, 0, len(node.Content.Labels.Nodes))
			for _, label := range node.Content.Labels.Nodes {
				labels = append(labels, label.Name)
			}

			// çŠ¶æ…‹ç†ç”±ã®å–å¾—
			stateReason := ""
			if node.Content.StateReason != nil {
				stateReason = *node.Content.StateReason
			}

			// ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‹ã‚‰è¦‹ç©æ™‚é–“ã€å®Ÿç¸¾æ™‚é–“ã€ã‚µã‚¤ã‚ºã‚’å–å¾—
			estimatedTime, actualTime, size := -1.0, -1.0, -1.0

			for _, fieldValue := range node.FieldValues.Nodes {
				if fieldValue.TypeName == "ProjectV2ItemFieldNumberValue" && fieldValue.Number != nil {
					switch fieldValue.Field.Name {
					case estimatedLabel:
						estimatedTime = *fieldValue.Number
					case actualLabel:
						actualTime = *fieldValue.Number
					case sizeLabel:
						size = *fieldValue.Number
					}
				}
			}

			// IssueTimeInfoã®ä½œæˆ
			issueInfo := IssueTimeInfo{
				IssueURL:      node.Content.URL,
				Title:         node.Content.Title,
				Author:        node.Content.Author.Login,
				Assignees:     assignees,
				CreatedAt:     createdAtJST,
				ClosedAt:      closedAt,
				State:         node.Content.State,
				StateReason:   stateReason,
				EstimatedTime: estimatedTime,
				ActualTime:    actualTime,
				Size:          size,
				Labels:        labels,
			}

			allIssues = append(allIssues, issueInfo)
		}

		// ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³å‡¦ç†
		if !response.Organization.ProjectV2.Items.PageInfo.HasNextPage {
			break
		}

		cursor = *response.Organization.ProjectV2.Items.PageInfo.EndCursor
	}

	return allIssues, nil
}

// filterIssues ã¯æŒ‡å®šã•ã‚ŒãŸãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã«åŸºã¥ã„ã¦Issueã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã™ã‚‹
func filterIssues(issues []IssueTimeInfo, options FilterOptions) []IssueTimeInfo {
	var filtered []IssueTimeInfo

	for _, issue := range issues {
		// ãƒªãƒã‚¸ãƒˆãƒªãƒ•ã‚£ãƒ«ã‚¿ãƒ¼
		if !isRepoInAllowedList(issue.IssueURL, options.AllowedRepositories) {
			continue
		}

		// sbiãƒ©ãƒ™ãƒ«ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ï¼ˆä»Šå›ã¯ç„¡åŠ¹åŒ–ã—ã¦ã™ã¹ã¦ã®Issueã‚’å¯¾è±¡ã«ã™ã‚‹ï¼‰
		if options.RequireSbiLabel && !containsLabel(issue.Labels, sbiLabel) && !containsLabel(issue.Labels, devSbiLabel) {
			continue
		}

		// NOT_PLANNEDã§ã‚¯ãƒ­ãƒ¼ã‚ºã•ã‚ŒãŸIssueã‚’é™¤å¤–
		if options.ExcludeNotPlanned && issue.StateReason == "NOT_PLANNED" {
			continue
		}

		// é–‰ã˜ã‚‰ã‚ŒãŸIssueã®ã¿ã‚’å¯¾è±¡ã¨ã™ã‚‹å ´åˆ
		if !options.IncludeOpenIssues && (issue.State != "CLOSED" || issue.ClosedAt == nil) {
			continue
		}

		// é–‰ã˜ã‚‰ã‚ŒãŸæ—¥ä»˜ã®ç¯„å›²ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
		if options.ClosedDateRange != nil && issue.ClosedAt != nil {
			if issue.ClosedAt.Before(options.ClosedDateRange.StartDate) ||
				issue.ClosedAt.After(options.ClosedDateRange.EndDate) {
				continue
			}
		}

		filtered = append(filtered, issue)
	}

	return filtered
}

// isRepoInAllowedList ã¯ãƒªãƒã‚¸ãƒˆãƒªãŒè¨±å¯ãƒªã‚¹ãƒˆå†…ã«ã‚ã‚‹ã‹ã‚’URLã‹ã‚‰åˆ¤æ–­ã™ã‚‹
func isRepoInAllowedList(issueURL string, allowedRepos []string) bool {
	for _, repo := range allowedRepos {
		repoURL := fmt.Sprintf("https://github.com/%s/%s", strings.Split(issueURL, "/")[3], repo)
		if strings.HasPrefix(issueURL, repoURL) {
			return true
		}
	}
	return false
}

// containsLabel ã¯æŒ‡å®šã—ãŸãƒ©ãƒ™ãƒ«ãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ã™ã‚‹
func containsLabel(labels []string, target string) bool {
	for _, label := range labels {
		if strings.EqualFold(label, target) {
			return true
		}
	}
	return false
}

// getGitHubToken ã¯GitHubãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç’°å¢ƒå¤‰æ•°ã¾ãŸã¯ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å–å¾—ã™ã‚‹
func getGitHubToken() string {
	token := os.Getenv("GITHUB_TOKEN")
	if token == "" {
		fn := os.Getenv("GITHUB_TOKEN_FILE")
		if fn == "" {
			log.Fatal("Neither GITHUB_TOKEN nor GITHUB_TOKEN_FILE environment variables are set")
		}

		tmp, err := os.ReadFile(fn)
		if err != nil {
			log.Fatalf("Error reading token file: %v", err)
		}
		token = strings.TrimSpace(string(tmp))
	}

	if token == "" {
		log.Fatal("GitHub token is empty")
	}

	return token
}

// hasAnySbiLabel ã¯sbié–¢é€£ã®ãƒ©ãƒ™ãƒ«ãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ã™ã‚‹
func hasAnySbiLabel(labels []string) bool {
	return containsLabel(labels, sbiLabel) || containsLabel(labels, devSbiLabel)
}

// hasAnyPbiLabel ã¯pbié–¢é€£ã®ãƒ©ãƒ™ãƒ«ãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ã™ã‚‹
func hasAnyPbiLabel(labels []string) bool {
	return containsLabel(labels, pbiLabel) || containsLabel(labels, devPbiLabel)
}

// getDifficultyFromLabels ã¯ãƒ©ãƒ™ãƒ«ã‹ã‚‰é›£æ˜“åº¦ã‚’ç‰¹å®šã™ã‚‹
func getDifficultyFromLabels(labels []string) string {
	if containsLabel(labels, diffLowLabel) {
		return "Low"
	} else if containsLabel(labels, diffMiddleLabel) {
		return "Middle"
	} else if containsLabel(labels, diffHighLabel) {
		return "High"
	}
	return ""
}

// getResponsiblePerson ã¯æ‹…å½“è€…ï¼ˆAssigneeã¾ãŸã¯ä½œæˆè€…ï¼‰ã‚’è¿”ã™
func getResponsiblePerson(issue IssueTimeInfo) string {
	if len(issue.Assignees) > 0 {
		return strings.Join(issue.Assignees, ", ")
	}
	return issue.Author
}

// validateAndDisplayIssuesWithIncorrectFields ã¯Issueã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¨­å®šã‚’æ¤œè¨¼ã—ã€
// ä¸æ­£ãªè¨­å®šã®Issueã‚’è¡¨ç¤ºã™ã‚‹
func validateAndDisplayIssuesWithIncorrectFields(issues []IssueTimeInfo) {
	// ã‚¯ãƒ­ãƒ¼ã‚ºç†ç”±ã§Issueã‚’åˆ†é¡
	var completedIssues []IssueTimeInfo
	var otherIssues []IssueTimeInfo

	for _, issue := range issues {
		if issue.StateReason == "COMPLETED" {
			completedIssues = append(completedIssues, issue)
		} else {
			otherIssues = append(otherIssues, issue)
		}
	}

	// å„ã‚°ãƒ«ãƒ¼ãƒ—ã”ã¨ã«æ¤œè¨¼ã¨è¡¨ç¤ºã‚’è¡Œã†
	fmt.Println("\n## Issues Closed as COMPLETED")
	validateAndDisplayIssueGroup(completedIssues)

	fmt.Println("\n## Issues Closed with Other Reasons")
	validateAndDisplayIssueGroup(otherIssues)
}

// validateAndDisplayIssueGroup ã¯ç‰¹å®šã®ã‚°ãƒ«ãƒ¼ãƒ—ã®Issueã‚’æ¤œè¨¼ã—è¡¨ç¤ºã™ã‚‹
func validateAndDisplayIssueGroup(issues []IssueTimeInfo) {
	var invalidIssues []struct {
		Issue             IssueTimeInfo
		Problems          []string
		ResponsiblePerson string
	}

	for _, issue := range issues {
		var problems []string

		// SBIãƒ©ãƒ™ãƒ«ï¼ˆsbi, dev-sbiï¼‰ã‚’æŒã¤Issueã¯ã€è¦‹ç©æ™‚é–“ãƒ»å®Ÿç¸¾æ™‚é–“ãƒ»é›£æ˜“åº¦ãƒ©ãƒ™ãƒ«ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹ã¹ã
		if hasAnySbiLabel(issue.Labels) {
			if issue.EstimatedTime < 0 {
				problems = append(problems, "è¦‹ç©æ™‚é–“ãŒæœªè¨­å®š")
			}
			if issue.ActualTime < 0 && issue.State == "CLOSED" {
				problems = append(problems, "å®Ÿç¸¾æ™‚é–“ãŒæœªè¨­å®š")
			}

			// é›£æ˜“åº¦ãƒ©ãƒ™ãƒ«ã®ãƒã‚§ãƒƒã‚¯
			difficulty := getDifficultyFromLabels(issue.Labels)
			if difficulty == "" {
				problems = append(problems, "é›£æ˜“åº¦ãƒ©ãƒ™ãƒ«ãŒæœªè¨­å®š")
			}
		}

		// PBIãƒ©ãƒ™ãƒ«ï¼ˆpbi, dev-pbiï¼‰ã‚’æŒã¤Issueã¯ã€ã‚µã‚¤ã‚ºãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹ã¹ã
		if hasAnyPbiLabel(issue.Labels) {
			if issue.Size < 0 {
				problems = append(problems, "ã‚µã‚¤ã‚ºãŒæœªè¨­å®š")
			}
		}

		if len(problems) > 0 {
			invalidIssues = append(invalidIssues, struct {
				Issue             IssueTimeInfo
				Problems          []string
				ResponsiblePerson string
			}{
				Issue:             issue,
				Problems:          problems,
				ResponsiblePerson: getResponsiblePerson(issue),
			})
		}
	}

	// æ¤œè¨¼çµæœã®å‡ºåŠ›
	if len(invalidIssues) == 0 {
		fmt.Printf("All %d issues have correct field values based on their labels. ğŸ‘\n", len(issues))
		return
	}

	fmt.Printf("Found %d issues with incorrect or missing field values out of %d total issues\n\n",
		len(invalidIssues), len(issues))
	fmt.Printf("| %-50s | %-30s | %-40s |\n", "Issue", "Responsible Person", "Problems")
	fmt.Println("|--------------------------------------------------|--------------------------------|------------------------------------------|")

	for _, item := range invalidIssues {
		issueTitle := item.Issue.Title
		if len(issueTitle) > 45 {
			issueTitle = issueTitle[:42] + "..."
		}

		// Markdownå½¢å¼ã®ãƒªãƒ³ã‚¯ã‚’ä½œæˆ
		issueLink := fmt.Sprintf("[%s](%s)", issueTitle, item.Issue.IssueURL)

		// å•é¡Œç‚¹ã®ãƒªã‚¹ãƒˆ
		problemStr := strings.Join(item.Problems, ", ")

		fmt.Printf("| %-50s | %-30s | %-40s |\n", issueLink, item.ResponsiblePerson, problemStr)
	}

	// ã‚µãƒãƒªãƒ¼æƒ…å ±
	fmt.Printf("\n### Summary\n\n")
	fmt.Printf("- Total issues with problems: %d (%.1f%%)\n",
		len(invalidIssues), float64(len(invalidIssues))/float64(len(issues))*100)

	// å•é¡Œã®ç¨®é¡ã”ã¨ã®é›†è¨ˆ
	problemCounts := make(map[string]int)
	for _, item := range invalidIssues {
		for _, problem := range item.Problems {
			problemCounts[problem]++
		}
	}

	fmt.Println("\n### Problem Types\n")
	for problem, count := range problemCounts {
		fmt.Printf("- %s: %d issues\n", problem, count)
	}

	// è²¬ä»»è€…ã”ã¨ã®é›†è¨ˆ
	personCounts := make(map[string]int)
	for _, item := range invalidIssues {
		personCounts[item.ResponsiblePerson]++
	}

	fmt.Println("\n### Issues by Responsible Person\n")
	// ã‚­ãƒ¼ã§ã‚½ãƒ¼ãƒˆã—ã¦ã‹ã‚‰å‡ºåŠ›
	var persons []string
	for person := range personCounts {
		persons = append(persons, person)
	}
	sort.Strings(persons)

	for _, person := range persons {
		count := personCounts[person]
		fmt.Printf("- %s: %d issues\n", person, count)
	}
}
